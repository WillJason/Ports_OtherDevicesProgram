C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\output\key.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE src\key.c BROWSE DEBUG OBJECTEXTEND PRINT(.\output\key.lst) OBJECT(.\output
                    -\key.obj)

line level    source

   1          #include "config.h"
   2          
   3          /*********************************************************************************************************
             -*********
   4                  
   5                                                          +--------------------------------------------------+
   6                                                                            按键的检测处理部分
   7                                                          +--------------------------------------------------+
   8          
   9           - 实现功能：
  10          
  11           - 目前进展：
  12          
  13           - 备注    ：按键采用的是3*4的矩阵按键，占用STC的7个IO
  14          **********************************************************************************************************
             -********/
  15          static INT8U MSG_FIFO = NO_MSG;
  16          static INT8U InputNumCnt = 0 ;
  17          static INT8U FolderNum = 0 ;//指定文件夹操作时的文件夹数目
  18          static INT8U FileNum = 0 ;//指定文件名操作时的文件名数目
  19          
  20          INT8U ErrorStatus = 0 ;
  21          INT8U FEEDBACK = 0 ;//是否需要反馈[=1:要应答][=0:不要应答]
  22          INT8U UartRecvStatus ;
  23          INT8U UartRecvACK ;
  24          INT8U UartRecv_100Ms ;//保证串口接收错误，也能回到初始状态
  25          INT8U System_Status = 0 ;//系统状态
  26          
  27          INT8U OutTimeCnt  = 0 ;//重发计时
  28          INT8U ResendCount = 5 ;//重发次数
  29          
  30          INT8U QueryACKTime = 0 ;//[查询参数]等待应答计时
  31          INT8U SysReturnTime = 0 ;//系统返回初始界面计时
  32          INT8U PlayledCnt = 0 ;//测试led点亮的时间
  33          INT8U PlayledStatus;
  34          INT8U CurrentEQ = 0 ;//当前的EQ
  35          INT8U PlayMode  = 0 ;//当前的播放模式
  36          INT8U PlayDevice = 0;//当前播放的设备
  37          INT8U OnlineDevice = 0 ;//在线的设备
  38          
  39          INT8U DelayTime = 0 ;
  40          
  41          INT8U input_vol = 0 ;//当前的音量
  42          INT8U CurrentModule = 0 ;//当前的模块型号
  43          INT8U PointFunc = 0 ;
  44          
  45          INT16U input_number ;//选曲输入的数字
  46          INT16U CurDevTotal = 0 ;//当前设备的总文件数
  47          INT16U UDiskTotal =0  ;//U盘总文件数
  48          INT16U TFTotal = 0 ;//TF卡文件数
  49          INT16U FlashTotal = 0 ;//FLASH中的文件数
  50          
  51          INT16U CurDevNUM = 0 ;//当前设备播放的曲目
  52          INT16U UDiskCurFile =0  ;//当前U盘播放的文件号
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 2   

  53          INT16U TFCurFile = 0 ;//当前TF播放的文件号
  54          INT16U FlashCurFile = 0 ;//当前FLASH播放的文件号
  55          
  56          /**********************************************************************
  57          - 1、按键采用的是3*4的矩阵按键。占用7个IO
  58          - 2、
  59          **********************************************************************/ 
  60          INT8U code key_table[12] = {
  61                                          0xED,0xDD,0xBD,0x7D,
  62                                          0xEB,0xDB,0xBB,0x7B,//4 
  63                                          0xE7,0xD7,0xB7,0x77  
  64                                     };
  65          //短按
  66          #define ADKEY_16KEY_MUSIC_SHORT                 \
  67          /* - 0 -*/              MSG_0,\
  68          /* - 1 -*/              MSG_1,\
  69          /* - 2 -*/              MSG_2,\
  70          /* - 3 -*/              MSG_3,\
  71          /* - 4 -*/              MSG_4,\
  72          /* - 5 -*/              MSG_5,\
  73          /* - 6 -*/              MSG_PLAYALL,\
  74          /* - 7 -*/              MSG_SET_PLAYMODE,\
  75          /* - 8 -*/              MSG_MUSIC_NEXT_FILE,\
  76          /* - 9 -*/              MSG_MUSIC_PREV_FILE,\
  77          /* - 10-*/              MSG_VOL_UP,\
  78          /* - 11-*/              MSG_VOL_DOWN,\
  79          
  80          //长按
  81          #define ADKEY_16KEY_MUSIC_LONG                  \
  82          /* - 0 -*/              MSG_MUSIC_NEXT_EQ,\
  83          /* - 1 -*/              MSG_MUSIC_PLAY,\
  84          /* - 2 -*/              MSG_MUSIC_PAUSE,\
  85          /* - 3 -*/              NO_MSG,\
  86          /* - 4 -*/              MSG_NEXT_WORKMODE,\
  87          /* - 5 -*/              MSG_QUERY_NUMTOTAL,\
  88          /* - 6 -*/              MSG_QUERY_CURNUM,\
  89          /* - 7 -*/              MSG_QUERY_VOL,\
  90          /* - 8 -*/              MSG_QUERY_EQ,\
  91          /* - 9 -*/              MSG_QUERY_PLAYMODE,\
  92          /* - 10-*/              MSG_TRIG_MODE,\
  93          /* - 11-*/              MSG_UART_ACK,\
  94          
  95          
  96          //按着不松手
  97          #define ADKEY_16KEY_MUSIC_HOLD                  \
  98          /* - 0 -*/              NO_MSG,\
  99          /* - 1 -*/              NO_MSG,\
 100          /* - 2 -*/              NO_MSG,\
 101          /* - 3 -*/              NO_MSG,\
 102          /* - 4 -*/              NO_MSG,\
 103          /* - 5 -*/              NO_MSG,\
 104          /* - 6 -*/              NO_MSG,\
 105          /* - 7 -*/              NO_MSG,\
 106          /* - 8 -*/              NO_MSG,\
 107          /* - 9 -*/              NO_MSG,\
 108          /* - 10-*/              NO_MSG,\
 109          /* - 11-*/              NO_MSG,\
 110          
 111          //按键抬起
 112          #define ADKEY_16KEY_MUSIC_LONG_UP               \
 113          /* - 0 -*/              NO_MSG,\
 114          /* - 1 -*/              NO_MSG,\
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 3   

 115          /* - 2 -*/              NO_MSG,\
 116          /* - 3 -*/              NO_MSG,\
 117          /* - 4 -*/              NO_MSG,\
 118          /* - 5 -*/              NO_MSG,\
 119          /* - 6 -*/              NO_MSG,\
 120          /* - 7 -*/              NO_MSG,\
 121          /* - 8 -*/              NO_MSG,\
 122          /* - 9 -*/              NO_MSG,\
 123          /* - 10-*/              NO_MSG,\
 124          /* - 11-*/              NO_MSG,\
 125                          
 126          
 127          INT8U code adkey_msg_16key_table[4][12] =               
 128          {
 129          /*短按--*/      {ADKEY_16KEY_MUSIC_SHORT},
 130          /*长按--*/      {ADKEY_16KEY_MUSIC_LONG},
 131          /*连按--*/      {ADKEY_16KEY_MUSIC_HOLD},
 132          /*长按抬起*/    {ADKEY_16KEY_MUSIC_LONG_UP},
 133          };
 134          
 135          
 136          void PointPlayNum(INT8U num) ;
 137          void PointPlayFolderNum(INT8U num);
 138          void DispModlueError(INT8U error);
 139          
 140          /*****************************************************************************************************
 141           - 功能描述： 将消息存入消息池
 142           - 隶属模块： 外部 
 143           - 参数说明： 无
 144           - 返回说明： 
 145           - 注：无 
 146          *****************************************************************************************************/
 147          void put_msg_lifo(INT8U msg)
 148          {
 149   1          MSG_FIFO = msg ;           
 150   1      }
 151          
 152          /*****************************************************************************************************
 153           - 功能描述： 取消息
 154           - 隶属模块： 外部 
 155           - 参数说明： 无
 156           - 返回说明： 
 157           - 注：无 
 158          *****************************************************************************************************/
 159          INT8U app_get_msg(void)
 160          {
 161   1          static INT8U msg ;
 162   1      
 163   1          msg = MSG_FIFO ;
 164   1          
 165   1          if(MSG_FIFO != NO_MSG)
 166   1          {
 167   2              MSG_FIFO = NO_MSG ;
 168   2              return msg ;
 169   2          }
 170   1          else
 171   1          {
 172   2              return NO_MSG ;//将消息清除
 173   2          }
 174   1      }
 175          /*****************************************************************************************************
 176           - 功能描述： Music 模式按键消息过滤处理
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 4   

 177           - 隶属模块： 外部 
 178           - 参数说明： 无
 179           - 返回说明： 检测到的按键值
 180           - 注：无 
 181          *****************************************************************************************************/
 182          
 183          void music_msg_filter(INT8U key_status, INT8U back_last_key)
 184          {
 185   1              INT8U msg;
 186   1      
 187   1              msg = adkey_msg_16key_table[key_status][back_last_key];//获取消息
 188   1      
 189   1              put_msg_lifo(msg);
 190   1      }
 191          
 192          
 193          
 194          /***************************************************************************
 195           - 功能描述： 按键去抖函数，输出稳定键值
 196           - 隶属模块： 外部
 197           - 参数说明： 无
 198           - 返回说明： 无
 199           - 注：      硬件的连接----矩阵式
 200          **************************************************************************/
 201          static INT8U KeyScan(void) 
 202          {
 203   1          INT8U i,temp;
 204   1          INT8U code *ptr;
 205   1          static INT8U g_key_value ;
 206   1          
 207   1              KEYIO   = 0x0f;
 208   1              temp = KEYIO & 0x0f;
 209   1              if(temp != 0x0f)//有键盘输入
 210   1              {
 211   2                      KEYIO = 0xf0;
 212   2                      g_key_value = temp|KEYIO;//得到键值
 213   2                      for(i=0,ptr=key_table; i<13; i++,ptr++) //查键值
 214   2                      {
 215   3                              if(g_key_value == *ptr)
 216   3                              {
 217   4                                      g_key_value = i;//得到键值
 218   4                                      return i ;
 219   4                              }
 220   3                      }
 221   2              return NO_KEY ;
 222   2          } 
 223   1              return NO_KEY ; 
 224   1      }
 225          
 226          
 227          /*****************************************************************************************************
 228           - 功能描述： 按键去抖函数，输出稳定键值
 229           - 隶属模块： 内部 
 230           - 参数说明： 无
 231           - 返回说明： 检测到的按键值
 232           - 注：无 
 233          *****************************************************************************************************/
 234          static INT8U key_filter(INT8U key)
 235          {
 236   1              static INT8U used_key = NO_KEY;
 237   1              static INT8U old_key;
 238   1              static INT8U key_counter;
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 5   

 239   1      
 240   1              if(old_key != key)
 241   1              {
 242   2                      key_counter = 0;
 243   2                      old_key = key;
 244   2              }
 245   1              else
 246   1              {
 247   2                      key_counter++;
 248   2                      if(key_counter == KEY_BASE_CNT)
 249   2                      {
 250   3                              used_key = key;
 251   3                      }
 252   2              }
 253   1      
 254   1              return used_key;
 255   1      }
 256          
 257          /*****************************************************************************************************
 258           - 功能描述： 按键-消息转换函数,按键产生顺序：短按抬起/长按-->连按
 259           - 隶属模块： 外部 
 260           - 参数说明： 无
 261           - 返回说明： 检测到的按键值
 262           - 注：       长按/短按/连按 --- OK 
 263          *****************************************************************************************************/
 264          void key_scan(void)
 265          {
 266   1              static INT8U last_key = NO_KEY;
 267   1              static INT8U key_press_counter;
 268   1              INT8U cur_key, key_status, back_last_key;
 269   1      
 270   1              cur_key = KeyScan();       //按键扫描
 271   1      
 272   1              cur_key = key_filter(cur_key);//过滤按键，相当于去抖
 273   1      
 274   1              back_last_key = last_key;
 275   1      
 276   1              if(cur_key == last_key)//长时间按键
 277   1              {
 278   2                      if(cur_key == NO_KEY)
 279   2                              return;
 280   2      
 281   2                      key_press_counter++;
 282   2      
 283   2                      if(key_press_counter == KEY_LONG_CNT)//长按
 284   2                      {
 285   3                              key_status = KEY_LONG;
 286   3                      }
 287   2                      else if(key_press_counter == (KEY_LONG_CNT + KEY_HOLD_CNT))//连按
 288   2                      {
 289   3                              key_status = KEY_HOLD;
 290   3                              key_press_counter = KEY_LONG_CNT;
 291   3                      }
 292   2                      else
 293   2                      {
 294   3                              return;
 295   3                      }
 296   2              }
 297   1              else  //cur_key = NO_KEY, 抬键
 298   1              {
 299   2                      last_key = cur_key;
 300   2                      if((key_press_counter < KEY_LONG_CNT) && (cur_key == NO_KEY))//短按抬起
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 6   

 301   2                      {
 302   3                              key_press_counter = 0;
 303   3                              key_status = KEY_SHORT_UP;
 304   3                      }
 305   2                      else
 306   2                      {
 307   3                              key_press_counter = 0;
 308   3                              return;
 309   3                      }
 310   2              }
 311   1            
 312   1          Put_u8(key_status) ;
 313   1          Put_u8(back_last_key) ;
 314   1              music_msg_filter(key_status, back_last_key);
 315   1      }
 316          
 317          /*****************************************************************************************************
 318           - 函数说明：消息处理
 319           - 隶属模块：内部
 320           - 参数说明：无
 321           - 返回说明：
 322           - 注      ：
 323          *****************************************************************************************************/
 324          void MSG_Task(void)
 325          {
 326   1          static INT8U msg ;
 327   1      
 328   1          msg = app_get_msg();
 329   1      
 330   1          switch(msg)
 331   1          {
 332   2             /*****************************************************
 333   2                                显示模块返回的错误
 334   2              *****************************************************/
 335   2              case MSG_RECV_ERROR:
 336   2                      DispModlueError(ErrorStatus);
 337   2                      SysReturnTime = SYSRETURNTIME ;           
 338   2                      break ;
 339   2                      
 340   2             /*****************************************************
 341   2                                返回初始状态
 342   2              *****************************************************/
 343   2              case MSG_RETURN_INIT:
 344   2                      RAM_Init() ;
 345   2                      LCD1602_Init();
 346   2                      DBG("MSG_RETURN_INIT\n") ;            
 347   2                      break ;
 348   2             /*****************************************************
 349   2                                设备插入
 350   2              *****************************************************/
 351   2              case MSG_UDISK_IN:
 352   2                      LCD1602_ClearLine(1);
 353   2                      LCD1602_DispStr(1 , 0  , "UDISK IN");
 354   2                      PlayDevice = PLAYDEVICE_UDISK ;
 355   2                      OnlineDevice |= BIT(UDISK) ;
 356   2                      SysReturnTime = SYSRETURNTIME ;
 357   2                      break ;
 358   2              case MSG_TF_IN:
 359   2                      LCD1602_ClearLine(1);
 360   2                      LCD1602_DispStr(1 , 0  , "TF IN");
 361   2                      PlayDevice = PLAYDEVICE_TFCARD ;
 362   2                      OnlineDevice |= BIT(TFCARD) ;
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 7   

 363   2                      SysReturnTime = SYSRETURNTIME ;
 364   2                      break ;
 365   2              case MSG_PC_IN:
 366   2                      LCD1602_ClearLine(1);
 367   2                      LCD1602_DispStr(1 , 0  , "PC IN");
 368   2                      PlayDevice = PLAYDEVICE_PC ;
 369   2                      OnlineDevice |= BIT(PC) ;
 370   2                      SysReturnTime = SYSRETURNTIME ;
 371   2                      break ;
 372   2             /*****************************************************
 373   2                                设备拔出
 374   2              *****************************************************/
 375   2              case MSG_UDISK_OUT:
 376   2                      LCD1602_ClearLine(1);
 377   2                      LCD1602_DispStr(1 , 0  , "UDISK OUT");
 378   2                      OnlineDevice &= ~BIT(UDISK) ;
 379   2                      GotoNextDevice(UDISK) ;
 380   2                      SysReturnTime = SYSRETURNTIME ;
 381   2                      break ;
 382   2              case MSG_TF_OUT:
 383   2                      LCD1602_ClearLine(1);
 384   2                      LCD1602_DispStr(1 , 0  , "TF OUT");
 385   2                      OnlineDevice &= ~BIT(TFCARD) ;
 386   2                      GotoNextDevice(TFCARD) ;
 387   2                      SysReturnTime = SYSRETURNTIME ;
 388   2                      break ;
 389   2              case MSG_PC_OUT:
 390   2                      LCD1602_ClearLine(1);
 391   2                      LCD1602_DispStr(1 , 0  , "PC OUT");
 392   2                      OnlineDevice &= ~BIT(PC) ;
 393   2                      GotoNextDevice(PC) ;
 394   2                      SysReturnTime = SYSRETURNTIME ;
 395   2                      break ;
 396   2             /*****************************************************
 397   2                                返回初始状态
 398   2              *****************************************************/
 399   2              case MSG_DELAY_TIME:
 400   2                      DelayTime = 6 ;        
 401   2                      break ;                   
 402   2      
 403   2             /*****************************************************
 404   2                                查询参数无应答
 405   2              *****************************************************/
 406   2              case MSG_QUERY_ERROR:
 407   2                      LCD1602_Clear() ;
 408   2                      LCD1602_DispStr(1 , 0  , "ERROR CMD");
 409   2                      SysReturnTime = SYSRETURNTIME ;
 410   2                      break ;
 411   2                      
 412   2             /*****************************************************
 413   2                                查询歌曲总数
 414   2              *****************************************************/
 415   2              case MSG_QUERY_NUMTOTAL:
 416   2                      LCD1602_Clear() ;
 417   2                      LCD1602_DispStr(0 , 0  , "QUERY TOTAL NUM ");    
 418   2      #if 1
 419   2                      if(PlayDevice == PLAYDEVICE_SLEEP)
 420   2                      {
 421   3                          LCD1602_Clear() ;
 422   3                          LCD1602_DispStr(1 , 0  , "MOD IN SLEEP  ");    
 423   3                          QueryACKTime = QUERYACKTIME ;//等待应答计时
 424   3                          break;
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 8   

 425   3                      }
 426   2      #endif
 427   2                      if(PlayDevice == PLAYDEVICE_UDISK)
 428   2                      {
 429   3                          Uart_SendCMD(UARTQUR_UDISK_TOTAL , FEEDBACK , 0);
 430   3                      }
 431   2                      else if(PlayDevice == PLAYDEVICE_TFCARD)
 432   2                      {
 433   3                          Uart_SendCMD(UARTQUR_TF_TOTAL , FEEDBACK , 0);   
 434   3                      }
 435   2                      else if(PlayDevice == PLAYDEVICE_FLASH)
 436   2                      {
 437   3                          Uart_SendCMD(UARTQUR_FLASH_TOTAL , FEEDBACK , 0);   
 438   3                      }
 439   2                      LCD1602_DispStr(1 , 0  , "WAIT RETURN ...."); 
 440   2                      QueryACKTime = QUERYACKTIME ;//等待应答计时
 441   2                      break ;
 442   2      
 443   2             /*****************************************************
 444   2                              显示查询当前播放设备曲目总数
 445   2              *****************************************************/
 446   2              case MSG_RETURN_NUMTOTAL:
 447   2                      QueryACKTime = 0 ;//清除等待超时
 448   2                      LCD1602_Clear() ;
 449   2                      LCD1602_DispStr(0 , 0  , "DEVICE:         "); 
 450   2                      LCD1602_DispStr(1 , 0  , "TOTAL NUM:      "); 
 451   2                      if(PlayDevice == PLAYDEVICE_UDISK)
 452   2                      {
 453   3                          CurDevTotal = UDiskTotal ;
 454   3                          LCD1602_DispStr(0 , 8  , "UDISK");     
 455   3                      }
 456   2                      else if(PlayDevice == PLAYDEVICE_TFCARD)
 457   2                      {
 458   3                          CurDevTotal = TFTotal ;
 459   3                          LCD1602_DispStr(0 , 8  , "TF");       
 460   3                      }
 461   2                      else if(PlayDevice == PLAYDEVICE_FLASH)
 462   2                      {
 463   3                          CurDevTotal = FlashTotal ;
 464   3                          LCD1602_DispStr(0 , 8  , "FLASH");      
 465   3                      }
 466   2                      itoa4(CurDevTotal);
 467   2                      LCD1602_DispStr(1 , 11 , (INT8U *)bcd_number);
 468   2                      SysReturnTime = SYSRETURNTIME ;
 469   2                      break ;
 470   2      
 471   2                      
 472   2             /*****************************************************
 473   2                                查询当前曲目
 474   2              *****************************************************/
 475   2              case MSG_QUERY_CURNUM:
 476   2                      LCD1602_Clear() ;
 477   2                      LCD1602_DispStr(0 , 0  , "QUERY CUR NUM   "); 
 478   2                      if(PlayDevice == PLAYDEVICE_SLEEP)
 479   2                      {
 480   3                          LCD1602_Clear() ;
 481   3                          LCD1602_DispStr(1 , 0  , "MOD IN SLEEP ");   
 482   3                          QueryACKTime = QUERYACKTIME ;//等待应答计时
 483   3                          break;
 484   3                      }  
 485   2                      if(PlayDevice == PLAYDEVICE_UDISK)
 486   2                      {
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 9   

 487   3                          Uart_SendCMD(UARTQUR_UDISK_FILE , FEEDBACK , 0);
 488   3                      }
 489   2                      else if(PlayDevice == PLAYDEVICE_TFCARD)
 490   2                      {
 491   3                          Uart_SendCMD(UARTQUR_TF_FILE , FEEDBACK , 0);   
 492   3                      }
 493   2                      else if(PlayDevice == PLAYDEVICE_FLASH)
 494   2                      {
 495   3                          Uart_SendCMD(UARTQUR_FLASH_FILE, FEEDBACK , 0);   
 496   3                      }
 497   2                      LCD1602_DispStr(1 , 0  , "WAIT RETURN ....");
 498   2      
 499   2                      QueryACKTime = QUERYACKTIME ;//等待应答计时
 500   2                      break ;
 501   2      
 502   2             /*****************************************************
 503   2                              显示查询当前播放曲目
 504   2              *****************************************************/
 505   2              case MSG_RETURN_CURNUM:
 506   2                      QueryACKTime = 0 ;//清除等待超时
 507   2                      LCD1602_Clear() ;
 508   2                      LCD1602_DispStr(0 , 0  , "DEVICE:         "); 
 509   2                      LCD1602_DispStr(1 , 0  , "CUR UM:            "); 
 510   2                      if(PlayDevice == PLAYDEVICE_UDISK)
 511   2                      {
 512   3                          CurDevNUM = UDiskCurFile ;
 513   3                          LCD1602_DispStr(0 , 8  , "UDISK");     
 514   3                      }
 515   2                      else if(PlayDevice == PLAYDEVICE_TFCARD)
 516   2                      {
 517   3                          CurDevNUM = TFCurFile ;
 518   3                          LCD1602_DispStr(0 , 8  , "TF");       
 519   3                      }
 520   2                      else if(PlayDevice == PLAYDEVICE_FLASH)
 521   2                      {
 522   3                          CurDevNUM = FlashCurFile ;
 523   3                          LCD1602_DispStr(0 , 8  , "FLASH");      
 524   3                      }
 525   2                      itoa4(CurDevNUM);
 526   2                      LCD1602_DispStr(1 , 11 , (INT8U *)bcd_number);
 527   2                      SysReturnTime = SYSRETURNTIME ;
 528   2                      break ;
 529   2             /*****************************************************
 530   2                                查询当前音量
 531   2              *****************************************************/
 532   2              case MSG_QUERY_VOL:
 533   2                      LCD1602_Clear() ;
 534   2                      LCD1602_DispStr(0 , 0  , "QUERY CUR VOL   ");
 535   2      #if 0
                              if(PlayDevice == PLAYDEVICE_SLEEP)
                              {
                                  LCD1602_DispStr(1 , 0  , "MOD IN SLEEP ");
                              }
                              else
              #endif
 542   2                      {
 543   3                          LCD1602_DispStr(1 , 0  , "WAIT RETURN ...."); 
 544   3                          Uart_SendCMD(UARTQUR_VOL , FEEDBACK , 0);
 545   3                      }
 546   2                      QueryACKTime = QUERYACKTIME ;//等待应答计时
 547   2                      break ;
 548   2      
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 10  

 549   2             /*****************************************************
 550   2                              显示查询当前音量的数据
 551   2              *****************************************************/
 552   2              case MSG_RETURN_VOL:
 553   2                      QueryACKTime = 0 ;//清除等待超时
 554   2                      LCD1602_Clear() ;
 555   2                      LCD1602_DispStr(1 , 0  , "VOL:            "); 
 556   2                      itoa2(input_vol);
 557   2                      LCD1602_DispStr(1 , 11 , (INT8U *)bcd_number);
 558   2                      SysReturnTime = SYSRETURNTIME ;
 559   2                      break ;
 560   2                      
 561   2             /*****************************************************
 562   2                                查询当前EQ
 563   2              *****************************************************/
 564   2              case MSG_QUERY_EQ:
 565   2                      LCD1602_Clear() ;
 566   2                      LCD1602_DispStr(0 , 0  , "QUERY CUR EQ    ");
 567   2      #if 1
 568   2                      if(PlayDevice == PLAYDEVICE_SLEEP)
 569   2                      {
 570   3                          LCD1602_DispStr(1 , 0  , "MOD IN SLEEP ");
 571   3                      }
 572   2                      else
 573   2      #endif
 574   2                      {
 575   3                          LCD1602_DispStr(1 , 0  , "WAIT RETURN ...."); 
 576   3                          Uart_SendCMD(UARTQUR_EQ , FEEDBACK , 0);
 577   3                      }
 578   2                      QueryACKTime = QUERYACKTIME ;//等待应答计时
 579   2                      break ;
 580   2      
 581   2             /*****************************************************
 582   2                              显示查询当前EQ的数据
 583   2              *****************************************************/
 584   2              case MSG_RETURN_EQ:
 585   2                      QueryACKTime = 0 ;//清除等待超时
 586   2                      LCD1602_Clear() ;
 587   2                      Disp_PlayEQ(CurrentEQ);
 588   2                      SysReturnTime = SYSRETURNTIME ;
 589   2                      break ;
 590   2      
 591   2                      
 592   2             /*****************************************************
 593   2                                查询当前播放模式
 594   2              *****************************************************/
 595   2              case MSG_QUERY_PLAYMODE:
 596   2                      LCD1602_Clear() ;
 597   2                      LCD1602_DispStr(0 , 0  , "QUERY PLAY MODE ");
 598   2      
 599   2                      if(PlayDevice == PLAYDEVICE_SLEEP)
 600   2                      {
 601   3                          LCD1602_DispStr(1 , 0  , "MOD IN SLEEP   ");
 602   3                      }
 603   2                      else
 604   2      
 605   2                      {
 606   3                          LCD1602_DispStr(1 , 0  , "WAIT RETURN ...."); 
 607   3                          Uart_SendCMD(UARTQUR_PLAYMODE , FEEDBACK , 0);
 608   3                      }
 609   2                      QueryACKTime = QUERYACKTIME ;//等待应答计时
 610   2                      break ;
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 11  

 611   2      
 612   2             /*****************************************************
 613   2                              显示查询当前播放模式的数据
 614   2              *****************************************************/
 615   2              case MSG_RETURN_PLAYMODE:
 616   2                      QueryACKTime = 0 ;//清除等待超时
 617   2                      LCD1602_Clear() ;
 618   2                      Disp_PlayMode(PlayMode);
 619   2                      SysReturnTime = SYSRETURNTIME ;
 620   2                      break ;
 621   2      
 622   2             /*****************************************************
 623   2                                显示模块初始化发出的数据
 624   2              *****************************************************/
 625   2              case MSG_RETURN_MINIT:
 626   2                      LCD1602_Clear() ;
 627   2                      LCD1602_DispStr(0 , 0  , "RECV MODL OK    ");
 628   2                      LCD1602_DispStr(1 , 0  , "ONLINE DEV:     ");
 629   2                      Disp_OnlineDevice(OnlineDevice);
 630   2                      GoInitDevice(OnlineDevice) ;
 631   2                      System_Status = SYS_STATUS_WORK ;
 632   2                      SysReturnTime = SYSRETURNTIME ;//定义3S的时候等待模块初始化完成
 633   2                      break ;
 634   2      #if 0
                     /*****************************************************
                                        切换工作模式
                      *****************************************************/
                      case MSG_TRIG_MODE:
                              TrigEnable = !TrigEnable ;
                              LCD1602_ClearLine(1);
                              if(TrigEnable == PLAYDEVICE_UDISK)
                              {
                                  LCD1602_DispStr(1 , 0  , "PLAYM :  TRIG");//1:触发模式
                              }
                              else
                              {
                                  LCD1602_DispStr(1 , 0  , "PLAYM :  CONT");//0:连续模式
                              }
                              SysReturnTime = SYSRETURNTIME ;
                              break ;
              #endif                
 652   2      
 653   2             /*****************************************************
 654   2                                切换当前播放设备
 655   2              *****************************************************/
 656   2              case MSG_NEXT_WORKMODE: 
 657   2                      LCD1602_Clear() ;
 658   2                      LCD1602_DispStr(0 , 0  , "PLAY DEVICE SET");
 659   2                      PlayDevice ++ ;
 660   2                      if(PlayDevice == PLAYDEVICE_MAX)
 661   2                      {
 662   3                          PlayDevice = PLAYDEVICE_UDISK;  
 663   3                      }
 664   2                      ChangeDevice(PlayDevice);
 665   2                      Disp_PlayDevice(PlayDevice);
 666   2                      Uart_SendCMD(UARTCMD_PLAYDEVICE , FEEDBACK , PlayDevice);
 667   2                      
 668   2                      SysReturnTime = SYSRETURNTIME ;
 669   2                      break ;
 670   2             /*****************************************************
 671   2                                EQ
 672   2              *****************************************************/
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 12  

 673   2              case MSG_MUSIC_NEXT_EQ:
 674   2                      LCD1602_Clear() ;
 675   2                      LCD1602_DispStr(0 , 0  , "EQ SET");
 676   2                      CurrentEQ ++ ;
 677   2                      if(CurrentEQ == EQ_BASS)
 678   2                      {
 679   3                          CurrentEQ = EQ_NORMAL;  
 680   3                      }
 681   2                      Uart_SendCMD(UARTCMD_EQ_POINT , FEEDBACK , CurrentEQ);
 682   2                      Disp_PlayEQ(CurrentEQ);
 683   2                      SysReturnTime = SYSRETURNTIME ;
 684   2                      break ;
 685   2      
 686   2             /*****************************************************
 687   2                                播放
 688   2              *****************************************************/
 689   2              case MSG_MUSIC_PLAY: 
 690   2                      Uart_SendCMD(UARTCMD_MUSIC_PLAY , FEEDBACK , 0);
 691   2                      DBG("MUSIC_PLAY\n") ;
 692   2                      LCD1602_ClearLine(1);
 693   2                      LCD1602_DispStr(1 , 0  , "MUSIC_PLAY");
 694   2                      SysReturnTime = SYSRETURNTIME ;
 695   2                      break ;
 696   2             /*****************************************************
 697   2                                暂停
 698   2              *****************************************************/
 699   2              case MSG_MUSIC_PAUSE: 
 700   2                      Uart_SendCMD(UARTCMD_MUSIC_PAUSE , FEEDBACK , 0);
 701   2                      DBG("MUSIC_PAUSE\n") ;
 702   2                      LCD1602_ClearLine(1);
 703   2                      LCD1602_DispStr(1 , 0  , "MUSIC_PAUSE");
 704   2                      SysReturnTime = SYSRETURNTIME ;
 705   2                      break ;                   
 706   2             /*****************************************************
 707   2                                下一曲
 708   2              *****************************************************/
 709   2              case MSG_MUSIC_NEXT_FILE:
 710   2                      if(input_vol > 0)
 711   2                      {
 712   3                          input_vol -- ;
 713   3                      }
 714   2                      Uart_SendCMD(UARTCMD_NEXT_FILE , FEEDBACK , 0);
 715   2                      DBG("MSG_MUSIC_NEXT_FILE\n") ;
 716   2                      LCD1602_ClearLine(1);
 717   2                      LCD1602_DispStr(1 , 0  , "NEXT FILE PLAY");
 718   2                      SysReturnTime = SYSRETURNTIME ;
 719   2                      break ;
 720   2      
 721   2             /*****************************************************
 722   2                                上一曲
 723   2              *****************************************************/
 724   2              case MSG_MUSIC_PREV_FILE:
 725   2                      Uart_SendCMD(UARTCMD_PREV_FILE , FEEDBACK , 0);
 726   2                      DBG("MSG_MUSIC_PREV_FILE\n") ;
 727   2                      LCD1602_ClearLine(1);
 728   2                      LCD1602_DispStr(1 , 0  , "PREV FILE PLAY");
 729   2                      SysReturnTime = SYSRETURNTIME ;
 730   2                      break ;
 731   2      
 732   2             /*****************************************************
 733   2                               循环播放模式设置
 734   2              *****************************************************/
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 13  

 735   2              case MSG_PLAYALL:
 736   2                      PlayAllFlag = !PlayAllFlag ;
 737   2                      LCD1602_ClearLine(1);
 738   2                      if(PlayAllFlag)
 739   2                      {
 740   3                          LCD1602_DispStr(1 , 0  , "ALL PLAY ON   ");
 741   3                          put_msg_lifo(MSG_PLAYALL_ON);
 742   3                          
 743   3                      }
 744   2                      else
 745   2                      {
 746   3                          LCD1602_DispStr(1 , 0  , "ALL PLAY OFF");
 747   3                          put_msg_lifo(MSG_PLAYALL_OFF);
 748   3                      }
 749   2                      break ;
 750   2             /*****************************************************
 751   2                               循环播放模式--开
 752   2              *****************************************************/
 753   2              case MSG_PLAYALL_ON:                
 754   2                      Uart_SendCMD(UARTCMD_PLAYALL , FEEDBACK , 0x01);
 755   2                      DBG("MSG_MUSIC_PREV_FILE\n") ;
 756   2                      SysReturnTime = SYSRETURNTIME ;
 757   2                      break ;
 758   2      
 759   2             /*****************************************************
 760   2                               循环播放模式--关
 761   2              *****************************************************/
 762   2              case MSG_PLAYALL_OFF:                
 763   2                      Uart_SendCMD(UARTCMD_PLAYALL , FEEDBACK , 0);
 764   2                      DBG("MSG_MUSIC_PREV_FILE\n") ;
 765   2                      SysReturnTime = SYSRETURNTIME ;
 766   2                      break ;
 767   2              /******************************************************
 768   2                                音量调节
 769   2               *****************************************************/
 770   2                  case MSG_VOL_UP:
 771   2                              input_vol++;
 772   2                              input_vol++;
 773   2              case MSG_VOL_DOWN:
 774   2                      input_vol--;
 775   2                      if ( input_vol == 255 )
 776   2                      {
 777   3                          input_vol = 0 ;
 778   3                      }
 779   2                      else if (input_vol > MAX_MAIN_VOL)
 780   2                      {
 781   3                          input_vol = MAX_MAIN_VOL ;
 782   3                      }
 783   2                      Uart_SendCMD(UARTCMD_VOL_POINT , FEEDBACK , input_vol);
 784   2      
 785   2                      LCD1602_ClearLine(1);
 786   2                      LCD1602_DispStr(1 , 0  , "CUR VOL[  ]");
 787   2                      SysReturnTime = SYSRETURNTIME ;
 788   2                      itoa2(input_vol);
 789   2                      LCD1602_DispStr(1 , 8 , (INT8U *)bcd_number);
 790   2                      break ;
 791   2                      
 792   2             /*****************************************************
 793   2                                输入超时处理
 794   2              *****************************************************/
 795   2                      case MSG_INPUT_TIMEOUT:
 796   2                      DBG("MSG_INPUT_TIMEOUT\n") ;
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 14  

 797   2                              put_msg_lifo(MSG_MUSIC_PLAY_NEW_FILE);
 798   2                              break;
 799   2                      
 800   2             /*****************************************************
 801   2                                选择指定的曲目
 802   2              *****************************************************/          
 803   2              case MSG_MUSIC_PLAY_NEW_FILE:
 804   2                                  DBG("MSG_MUSIC_PLAY_NEW_FILE\n") ;
 805   2                      LCD1602_Clear() ;
 806   2                      if(PlayDevice == PLAYDEVICE_SLEEP)
 807   2                      {
 808   3                          LCD1602_DispStr(1 , 0  , "MOD IN SLEEP ");
 809   3                      }
 810   2                      else
 811   2                      {
 812   3                          if(POINTNUM_ONE == PointFunc)//指定单曲播放
 813   3                          {
 814   4                              Uart_SendCMD(UARTCMD_NUM_POINT , FEEDBACK , input_number);
 815   4                              LCD1602_DispStr(1 , 0  , "SEND ONE NUM ");
 816   4                          }
 817   3                          else if(POINTNUM_LOOP == PointFunc)//指定单曲循环播放
 818   3                          {
 819   4                              Uart_SendCMD(UARTCMD_LOOP_PLAY , FEEDBACK , input_number);
 820   4                              LCD1602_DispStr(1 , 0  , "SEND LOOP NUM ");
 821   4                          }
 822   3                          else if(POINTNUM_FOLDER == PointFunc)//指定文件夹和文件
 823   3                          {
 824   4                              input_number = ((INT16U)(FolderNum)<<8)| FileNum ;
 825   4                              FileNum  = 0 ; 
 826   4                              FolderNum= 0 ;
 827   4                              Uart_SendCMD(UARTCMD_MUSIC_FOLDER , FEEDBACK , input_number);
 828   4                              LCD1602_DispStr(1 , 0  , "FOLD FILE POINT");
 829   4                          }
 830   3                      }          
 831   2                      input_number = 0 ;
 832   2                      SysReturnTime = SYSRETURNTIME ;
 833   2                                  break;
 834   2      
 835   2             /*****************************************************
 836   2                            指定文件夹以及指定文件名
 837   2              *****************************************************/          
 838   2                      
 839   2              case MSG_SET_PLAYMODE:
 840   2                      if((++PointFunc) == POINTNUM_MAX)
 841   2                      {
 842   3                          PointFunc = POINTNUM_ONE ;   
 843   3                      }
 844   2                      SysReturnTime = SYSRETURNTIME ;
 845   2                      LCD1602_ClearLine(1);
 846   2                      if(PointFunc == POINTNUM_ONE)
 847   2                      {
 848   3                          LCD1602_DispStr(1 , 0  , "POINT ONE      ");
 849   3                      }
 850   2                      else if(PointFunc == POINTNUM_LOOP)
 851   2                      {
 852   3                          LCD1602_DispStr(1 , 0  , "POINT LOOP     ");   
 853   3                      }
 854   2                      else if(PointFunc == POINTNUM_FOLDER)
 855   2                      {
 856   3                          LCD1602_DispStr(1 , 0  , "POINT FOLDER   ");    
 857   3                      }
 858   2                                  break;
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 15  

 859   2      
 860   2             /*****************************************************
 861   2                                切换是否需要反馈
 862   2              *****************************************************/          
 863   2                      
 864   2              case MSG_UART_ACK:
 865   2                      LCD1602_ClearLine(1);
 866   2                      if(FEEDBACK)
 867   2                      {
 868   3                          FEEDBACK = 0 ;
 869   3                          LCD1602_DispStr(1 , 0  , "NO NEED ACK");
 870   3                      }
 871   2                      else
 872   2                      {
 873   3                          FEEDBACK = 1 ;
 874   3                          LCD1602_DispStr(1 , 0  , "NEED ACK");
 875   3                      }    
 876   2                      SysReturnTime = SYSRETURNTIME ;
 877   2                                  break;
 878   2             /*****************************************************
 879   2                                数字键操作，用于数字选曲
 880   2                                和文件夹指定，文件名指定
 881   2              *****************************************************/
 882   2              case MSG_0:
 883   2              case MSG_1:
 884   2              case MSG_2:
 885   2              case MSG_3:
 886   2              case MSG_4:
 887   2              case MSG_5:
 888   2              case MSG_6:
 889   2              case MSG_7:
 890   2              case MSG_8:
 891   2              case MSG_9:
 892   2                      if(POINTNUM_FOLDER == PointFunc)//指定文件夹的状态
 893   2                      {
 894   3                          PointPlayFolderNum(msg);                 
 895   3                      }
 896   2                      else
 897   2                      {
 898   3                          PointPlayNum(msg) ;                 
 899   3                      }
 900   2                      break ;
 901   2          }
 902   1      }
 903          /*****************************************************************************************************
 904           - 函数说明：显示模块返回的错误
 905           - 隶属模块：内部
 906           - 参数说明：无
 907           - 返回说明：
 908           - 注      ：
 909          
 910          *****************************************************************************************************/
 911          void DispModlueError(INT8U error)
 912          {
 913   1          LCD1602_Clear();
 914   1          LCD1602_DispStr(0 , 0  , "RETURN ERROR    ");
 915   1          switch(error)
 916   1          {
 917   2              case ERROR_IDLE :
 918   2                              
 919   2                              break ;
 920   2              case ERROR_Busy :
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 16  

 921   2                              LCD1602_DispStr(1 , 0  , "BUSY    ");
 922   2                              break ;
 923   2              case ERROR_SLEEP :
 924   2                              LCD1602_DispStr(1 , 0  , "SLEEP    ");
 925   2                              break ;
 926   2              case ERROR_RecvError :
 927   2                              LCD1602_DispStr(1 , 0  , "RECV ERROR   ");
 928   2                              break ;
 929   2              case ERROR_CheckSError :
 930   2                              LCD1602_DispStr(1 , 0  , "SUM ERROR    ");
 931   2                              break ;
 932   2              case ERROR_FolPointOver :
 933   2                              LCD1602_DispStr(1 , 0  , "FOL OVER     ");
 934   2                              break ;
 935   2              case ERROR_FolPointNo :
 936   2                              LCD1602_DispStr(1 , 0  , "NO FIND FILE ");
 937   2                              break ;
 938   2          }
 939   1      }
 940          
 941          /*****************************************************************************************************
 942           - 函数说明：数字选曲操作
 943           - 隶属模块：内部
 944           - 参数说明：无
 945           - 返回说明：
 946           - 注      ：
 947          *****************************************************************************************************/
 948          void PointPlayNum(INT8U num)
 949          {
 950   1          DBG("MSG_input_num\n") ;
 951   1          if(0 == InputNumCnt)
 952   1          {
 953   2              LCD1602_ClearLine(1);
 954   2          }
 955   1          InputNumCnt = 30 ;//连续3S没有按键按下,输入超时
 956   1          SysReturnTime = 0 ;
 957   1          LCD1602_DispStr(1 , 0  , "INPUT NUM:[");
 958   1          LCD1602_DispStr(1 , 15 , "]");
 959   1          
 960   1          input_number = input_number * 10 + num ;
 961   1          if ( input_number > 1999 )
 962   1          {
 963   2              input_number = 0;
 964   2          }
 965   1          itoa4(input_number);
 966   1          LCD1602_DispStr(1 , 11 , (INT8U *)bcd_number);    
 967   1      }
 968          
 969          /*****************************************************************************************************
 970           - 函数说明：指定文件夹以及文件名操作
 971           - 隶属模块：内部
 972           - 参数说明：无
 973           - 返回说明：
 974           - 注      ：
 975          *****************************************************************************************************/
 976          void PointPlayFolderNum(INT8U num)
 977          {
 978   1          static INT8U InputCnt = 0 ; 
 979   1          DBG("MSG_input_num\n") ;
 980   1          if(0 == InputNumCnt)
 981   1          {
 982   2              InputCnt = 5 ;
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 17  

 983   2              LCD1602_Clear();
 984   2              LCD1602_DispStr(0 , 0  , "FOLD NUM[  ]");//指定的文件夹
 985   2              LCD1602_DispStr(1 , 0  , "FILE NUM[   ]");//指定的文件名
 986   2          }
 987   1          InputNumCnt = 30 ;//连续3S没有按键按下,输入超时
 988   1          SysReturnTime = 0 ;
 989   1          if(InputCnt > 3)
 990   1          {
 991   2              FolderNum = FolderNum * 10 + num ;
 992   2              if( FileNum > 99 )
 993   2              {
 994   3                  FileNum = 0;
 995   3              }
 996   2              itoa2(FolderNum);
 997   2              LCD1602_DispStr(0 , 9 , (INT8U *)bcd_number);  
 998   2          }
 999   1          else
1000   1          {
1001   2              FileNum = FileNum * 10 + num ;
1002   2              if( FileNum > 255 )
1003   2              {
1004   3                  FileNum = 0;
1005   3              }
1006   2              itoa3(FileNum);
1007   2              LCD1602_DispStr(1 , 9 , (INT8U *)bcd_number);  
1008   2          }  
1009   1          if((--InputCnt) == 0)
1010   1          {
1011   2              InputCnt = 0 ;
1012   2              InputNumCnt = 10 ;        
1013   2          }
1014   1      }
1015          
1016          /*****************************************************************************************************
1017           - 函数说明：播放指示灯[100ms处理一次]
1018           - 隶属模块：内部
1019           - 参数说明：无
1020           - 返回说明：
1021           - 注      ：
1022          *****************************************************************************************************/
1023          void Indicator_Scan(void)
1024          {
1025   1              static INT8U flash_cnt;
1026   1      
1027   1              switch(PlayledStatus)
1028   1              {
1029   2              case SET_PLAYLED_ON:                    
1030   2                      PLAYLED_ON;
1031   2                      break;
1032   2              case SET_PLAYLED_OFF:                   
1033   2                      PLAYLED_OFF;
1034   2                      break;
1035   2              case SET_PLAYLED_100MS_FLASH:   
1036   2                      PLAYLED_FLASH;
1037   2                      break;
1038   2              case SET_PLAYLED_500MS_FLASH:   
1039   2                      if(++flash_cnt > 4)
1040   2                      {
1041   3                              flash_cnt = 0;
1042   3                              PLAYLED_FLASH;
1043   3                      }
1044   2                      break;
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 18  

1045   2              case SET_PLAYLED_900MS_ON_100MS_OFF:
1046   2                      if(++flash_cnt > 4)
1047   2                      {
1048   3                              flash_cnt = 0;
1049   3                              PLAYLED_ON;
1050   3                      }
1051   2                      else
1052   2                      {
1053   3                              PLAYLED_OFF;
1054   3                      }
1055   2                      break;
1056   2              }
1057   1      }
1058          
1059          /*****************************************************************************************************
1060           - 函数说明：定时[100ms运行一次]
1061           - 隶属模块：内部
1062           - 参数说明：无
1063           - 返回说明：
1064           - 注      ：
1065          *****************************************************************************************************/
1066          void Time_Task(void) 
1067          {
1068   1          if((DelayTime) && ((--DelayTime) == 0))
1069   1              {               
1070   2              put_msg_lifo(MSG_MUSIC_PLAY); ;//       
1071   2              }
1072   1          if((UartRecv_100Ms) && ((--UartRecv_100Ms) == 0))
1073   1              {               
1074   2              UartRecvStatus = UART_RECV_IDLE ;//串口接收限定时间未接收完毕           
1075   2              }
1076   1          if((PlayledCnt) && ((--PlayledCnt) == 0)) 
1077   1              {       
1078   2              PlayledStatus = SET_PLAYLED_OFF ;
1079   2              }   
1080   1          if((InputNumCnt) && ((--InputNumCnt) == 0)) 
1081   1              {       
1082   2              put_msg_lifo(MSG_INPUT_TIMEOUT);
1083   2              }  
1084   1          if((SysReturnTime) && ((--SysReturnTime) == 0)) 
1085   1              {       
1086   2                  if(System_Status == SYS_STATUS_INIT)
1087   2              {
1088   3                  put_msg_lifo(MSG_RETURN_INIT);
1089   3              }
1090   2              else if(System_Status == SYS_STATUS_WORK)
1091   2              {
1092   3                  put_msg_lifo(MSG_RETURN_INIT);
1093   3              }
1094   2              }   
1095   1          if((UartRecvACK) && ((--UartRecvACK) == 0)) //没有收到应答
1096   1              {       
1097   2                  if(FEEDBACK)
1098   2              {
1099   3                      PlayledCnt = PLAYLEDCNT ; 
1100   3                          PlayledStatus = SET_PLAYLED_100MS_FLASH ;
1101   3              }
1102   2              }   
1103   1          if((QueryACKTime) && ((--QueryACKTime) == 0)) //没有收到应答
1104   1              {       
1105   2                  if(PlayDevice == PLAYDEVICE_NULL)
1106   2              {
C51 COMPILER V9.01   KEY                                                                   07/20/2013 21:47:02 PAGE 19  

1107   3                  SysReturnTime = 1 ;    
1108   3              }
1109   2              else
1110   2              {   
1111   3                  put_msg_lifo(MSG_QUERY_ERROR);
1112   3              }
1113   2              } 
1114   1      }
1115          
1116          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2302    ----
   CONSTANT SIZE    =    745    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
